//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from calcExpr.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class calcExprParser : Parser {
	public const int
		OR=1, AND=2, LT=3, GT=4, LEQ=5, GEQ=6, EQ=7, NEQ=8, PLUS=9, MINUS=10, 
		MULT=11, DIV=12, MOD=13, DOT=14, COMMA=15, QUOT=16, EQU=17, COLON=18, 
		OPEN_PAREN=19, CLOSE_PAREN=20, NULL=21, TRUE=22, FALSE=23, VARID=24, STRING=25, 
		ESC_SEQ=26, NUMBER=27, DIGIT=28, WHITESPACE=29;
	public const int
		RULE_parse = 0, RULE_expr = 1, RULE_or_expr = 2, RULE_or_body = 3, RULE_and_expr = 4, 
		RULE_and_body = 5, RULE_rel_expr = 6, RULE_eq_expr = 7, RULE_add_expr = 8, 
		RULE_add_body = 9, RULE_mult_expr = 10, RULE_mult_body = 11, RULE_unary_expr = 12, 
		RULE_atom = 13, RULE_var = 14, RULE_params = 15, RULE_unaryparam = 16, 
		RULE_briefparam = 17;
	public static readonly string[] ruleNames = {
		"parse", "expr", "or_expr", "or_body", "and_expr", "and_body", "rel_expr", 
		"eq_expr", "add_expr", "add_body", "mult_expr", "mult_body", "unary_expr", 
		"atom", "var", "params", "unaryparam", "briefparam"
	};

	private static readonly string[] _LiteralNames = {
		null, "'||'", "'&&'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", "'+'", 
		"'-'", "'*'", "'/'", "'%'", "'.'", "','", "'\"'", "'='", "':'", "'('", 
		"')'", "'null'", "'true'", "'false'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "OR", "AND", "LT", "GT", "LEQ", "GEQ", "EQ", "NEQ", "PLUS", "MINUS", 
		"MULT", "DIV", "MOD", "DOT", "COMMA", "QUOT", "EQU", "COLON", "OPEN_PAREN", 
		"CLOSE_PAREN", "NULL", "TRUE", "FALSE", "VARID", "STRING", "ESC_SEQ", 
		"NUMBER", "DIGIT", "WHITESPACE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "calcExpr.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public calcExprParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class ParseContext : ParserRuleContext {
		public ITerminalNode EQU() { return GetToken(calcExprParser.EQU, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ParseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parse; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterParse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitParse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParseContext parse() {
		ParseContext _localctx = new ParseContext(Context, State);
		EnterRule(_localctx, 0, RULE_parse);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 36; Match(EQU);
			State = 37; expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public Or_exprContext or_expr() {
			return GetRuleContext<Or_exprContext>(0);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_expr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 39; or_expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Or_exprContext : ParserRuleContext {
		public And_exprContext left;
		public And_exprContext and_expr() {
			return GetRuleContext<And_exprContext>(0);
		}
		public Or_bodyContext[] or_body() {
			return GetRuleContexts<Or_bodyContext>();
		}
		public Or_bodyContext or_body(int i) {
			return GetRuleContext<Or_bodyContext>(i);
		}
		public Or_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_or_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterOr_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitOr_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOr_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Or_exprContext or_expr() {
		Or_exprContext _localctx = new Or_exprContext(Context, State);
		EnterRule(_localctx, 4, RULE_or_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 41; _localctx.left = and_expr();
			State = 45;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==OR) {
				{
				{
				State = 42; or_body();
				}
				}
				State = 47;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Or_bodyContext : ParserRuleContext {
		public IToken op;
		public And_exprContext and_expr() {
			return GetRuleContext<And_exprContext>(0);
		}
		public ITerminalNode OR() { return GetToken(calcExprParser.OR, 0); }
		public Or_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_or_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterOr_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitOr_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOr_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Or_bodyContext or_body() {
		Or_bodyContext _localctx = new Or_bodyContext(Context, State);
		EnterRule(_localctx, 6, RULE_or_body);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 48; _localctx.op = Match(OR);
			State = 49; and_expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class And_exprContext : ParserRuleContext {
		public Rel_exprContext left;
		public Rel_exprContext rel_expr() {
			return GetRuleContext<Rel_exprContext>(0);
		}
		public And_bodyContext[] and_body() {
			return GetRuleContexts<And_bodyContext>();
		}
		public And_bodyContext and_body(int i) {
			return GetRuleContext<And_bodyContext>(i);
		}
		public And_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_and_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterAnd_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitAnd_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnd_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public And_exprContext and_expr() {
		And_exprContext _localctx = new And_exprContext(Context, State);
		EnterRule(_localctx, 8, RULE_and_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 51; _localctx.left = rel_expr();
			State = 55;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==AND) {
				{
				{
				State = 52; and_body();
				}
				}
				State = 57;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class And_bodyContext : ParserRuleContext {
		public IToken op;
		public Rel_exprContext rel_expr() {
			return GetRuleContext<Rel_exprContext>(0);
		}
		public ITerminalNode AND() { return GetToken(calcExprParser.AND, 0); }
		public And_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_and_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterAnd_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitAnd_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnd_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public And_bodyContext and_body() {
		And_bodyContext _localctx = new And_bodyContext(Context, State);
		EnterRule(_localctx, 10, RULE_and_body);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; _localctx.op = Match(AND);
			State = 59; rel_expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rel_exprContext : ParserRuleContext {
		public Eq_exprContext left;
		public IToken op;
		public Eq_exprContext[] eq_expr() {
			return GetRuleContexts<Eq_exprContext>();
		}
		public Eq_exprContext eq_expr(int i) {
			return GetRuleContext<Eq_exprContext>(i);
		}
		public ITerminalNode LT() { return GetToken(calcExprParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(calcExprParser.GT, 0); }
		public ITerminalNode LEQ() { return GetToken(calcExprParser.LEQ, 0); }
		public ITerminalNode GEQ() { return GetToken(calcExprParser.GEQ, 0); }
		public Rel_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rel_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterRel_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitRel_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRel_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rel_exprContext rel_expr() {
		Rel_exprContext _localctx = new Rel_exprContext(Context, State);
		EnterRule(_localctx, 12, RULE_rel_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 61; _localctx.left = eq_expr();
			State = 64;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << GT) | (1L << LEQ) | (1L << GEQ))) != 0)) {
				{
				State = 62;
				_localctx.op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << GT) | (1L << LEQ) | (1L << GEQ))) != 0)) ) {
					_localctx.op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 63; eq_expr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Eq_exprContext : ParserRuleContext {
		public Add_exprContext left;
		public IToken op;
		public Add_exprContext[] add_expr() {
			return GetRuleContexts<Add_exprContext>();
		}
		public Add_exprContext add_expr(int i) {
			return GetRuleContext<Add_exprContext>(i);
		}
		public ITerminalNode EQ() { return GetToken(calcExprParser.EQ, 0); }
		public ITerminalNode NEQ() { return GetToken(calcExprParser.NEQ, 0); }
		public Eq_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eq_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterEq_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitEq_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEq_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Eq_exprContext eq_expr() {
		Eq_exprContext _localctx = new Eq_exprContext(Context, State);
		EnterRule(_localctx, 14, RULE_eq_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 66; _localctx.left = add_expr();
			State = 69;
			_la = TokenStream.La(1);
			if (_la==EQ || _la==NEQ) {
				{
				State = 67;
				_localctx.op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !(_la==EQ || _la==NEQ) ) {
					_localctx.op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 68; add_expr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_exprContext : ParserRuleContext {
		public Mult_exprContext left;
		public Mult_exprContext mult_expr() {
			return GetRuleContext<Mult_exprContext>(0);
		}
		public Add_bodyContext[] add_body() {
			return GetRuleContexts<Add_bodyContext>();
		}
		public Add_bodyContext add_body(int i) {
			return GetRuleContext<Add_bodyContext>(i);
		}
		public Add_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterAdd_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitAdd_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_exprContext add_expr() {
		Add_exprContext _localctx = new Add_exprContext(Context, State);
		EnterRule(_localctx, 16, RULE_add_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 71; _localctx.left = mult_expr();
			State = 75;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PLUS || _la==MINUS) {
				{
				{
				State = 72; add_body();
				}
				}
				State = 77;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_bodyContext : ParserRuleContext {
		public IToken op;
		public Mult_exprContext mult_expr() {
			return GetRuleContext<Mult_exprContext>(0);
		}
		public ITerminalNode PLUS() { return GetToken(calcExprParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(calcExprParser.MINUS, 0); }
		public Add_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterAdd_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitAdd_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_bodyContext add_body() {
		Add_bodyContext _localctx = new Add_bodyContext(Context, State);
		EnterRule(_localctx, 18, RULE_add_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 78;
			_localctx.op = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
				_localctx.op = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 79; mult_expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Mult_exprContext : ParserRuleContext {
		public Unary_exprContext left;
		public Unary_exprContext unary_expr() {
			return GetRuleContext<Unary_exprContext>(0);
		}
		public Mult_bodyContext[] mult_body() {
			return GetRuleContexts<Mult_bodyContext>();
		}
		public Mult_bodyContext mult_body(int i) {
			return GetRuleContext<Mult_bodyContext>(i);
		}
		public Mult_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mult_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterMult_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitMult_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mult_exprContext mult_expr() {
		Mult_exprContext _localctx = new Mult_exprContext(Context, State);
		EnterRule(_localctx, 20, RULE_mult_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81; _localctx.left = unary_expr();
			State = 85;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==MULT || _la==DIV) {
				{
				{
				State = 82; mult_body();
				}
				}
				State = 87;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Mult_bodyContext : ParserRuleContext {
		public IToken op;
		public Unary_exprContext unary_expr() {
			return GetRuleContext<Unary_exprContext>(0);
		}
		public ITerminalNode MULT() { return GetToken(calcExprParser.MULT, 0); }
		public ITerminalNode DIV() { return GetToken(calcExprParser.DIV, 0); }
		public Mult_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mult_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterMult_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitMult_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mult_bodyContext mult_body() {
		Mult_bodyContext _localctx = new Mult_bodyContext(Context, State);
		EnterRule(_localctx, 22, RULE_mult_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88;
			_localctx.op = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !(_la==MULT || _la==DIV) ) {
				_localctx.op = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 89; unary_expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_exprContext : ParserRuleContext {
		public IToken op;
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode PLUS() { return GetToken(calcExprParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(calcExprParser.MINUS, 0); }
		public Unary_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterUnary_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitUnary_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_exprContext unary_expr() {
		Unary_exprContext _localctx = new Unary_exprContext(Context, State);
		EnterRule(_localctx, 24, RULE_unary_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92;
			_la = TokenStream.La(1);
			if (_la==PLUS || _la==MINUS) {
				{
				State = 91;
				_localctx.op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
					_localctx.op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 94; atom();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
	 
		public AtomContext() { }
		public virtual void CopyFrom(AtomContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TrueValueContext : AtomContext {
		public ITerminalNode TRUE() { return GetToken(calcExprParser.TRUE, 0); }
		public TrueValueContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterTrueValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitTrueValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrueValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FalseValueContext : AtomContext {
		public ITerminalNode FALSE() { return GetToken(calcExprParser.FALSE, 0); }
		public FalseValueContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterFalseValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitFalseValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFalseValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstStringContext : AtomContext {
		public ITerminalNode STRING() { return GetToken(calcExprParser.STRING, 0); }
		public ConstStringContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterConstString(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitConstString(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BraceExprContext : AtomContext {
		public ITerminalNode OPEN_PAREN() { return GetToken(calcExprParser.OPEN_PAREN, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode CLOSE_PAREN() { return GetToken(calcExprParser.CLOSE_PAREN, 0); }
		public BraceExprContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterBraceExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitBraceExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBraceExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NullValueContext : AtomContext {
		public ITerminalNode NULL() { return GetToken(calcExprParser.NULL, 0); }
		public NullValueContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterNullValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitNullValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncContext : AtomContext {
		public IToken funcname;
		public ITerminalNode OPEN_PAREN() { return GetToken(calcExprParser.OPEN_PAREN, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(calcExprParser.CLOSE_PAREN, 0); }
		public ITerminalNode VARID() { return GetToken(calcExprParser.VARID, 0); }
		public ParamsContext @params() {
			return GetRuleContext<ParamsContext>(0);
		}
		public FuncContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterFunc(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitFunc(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstNumberContext : AtomContext {
		public ITerminalNode NUMBER() { return GetToken(calcExprParser.NUMBER, 0); }
		public ConstNumberContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterConstNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitConstNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableContext : AtomContext {
		public VarContext var() {
			return GetRuleContext<VarContext>(0);
		}
		public VariableContext(AtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 26, RULE_atom);
		int _la;
		try {
			State = 112;
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				_localctx = new FuncContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 96; ((FuncContext)_localctx).funcname = Match(VARID);
				State = 97; Match(OPEN_PAREN);
				State = 99;
				_la = TokenStream.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PLUS) | (1L << MINUS) | (1L << OPEN_PAREN) | (1L << NULL) | (1L << TRUE) | (1L << FALSE) | (1L << VARID) | (1L << STRING) | (1L << NUMBER))) != 0)) {
					{
					State = 98; @params();
					}
				}

				State = 101; Match(CLOSE_PAREN);
				}
				break;
			case 2:
				_localctx = new ConstNumberContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 102; Match(NUMBER);
				}
				break;
			case 3:
				_localctx = new ConstStringContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 103; Match(STRING);
				}
				break;
			case 4:
				_localctx = new VariableContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 104; var();
				}
				break;
			case 5:
				_localctx = new NullValueContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 105; Match(NULL);
				}
				break;
			case 6:
				_localctx = new TrueValueContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 106; Match(TRUE);
				}
				break;
			case 7:
				_localctx = new FalseValueContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 107; Match(FALSE);
				}
				break;
			case 8:
				_localctx = new BraceExprContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 108; Match(OPEN_PAREN);
				State = 109; expr();
				State = 110; Match(CLOSE_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarContext : ParserRuleContext {
		public ITerminalNode VARID() { return GetToken(calcExprParser.VARID, 0); }
		public VarContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_var; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterVar(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitVar(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVar(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VarContext var() {
		VarContext _localctx = new VarContext(Context, State);
		EnterRule(_localctx, 28, RULE_var);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 114; Match(VARID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamsContext : ParserRuleContext {
		public ParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_params; } }
	 
		public ParamsContext() { }
		public virtual void CopyFrom(ParamsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MultiExprContext : ParamsContext {
		public UnaryparamContext left;
		public UnaryparamContext[] unaryparam() {
			return GetRuleContexts<UnaryparamContext>();
		}
		public UnaryparamContext unaryparam(int i) {
			return GetRuleContext<UnaryparamContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(calcExprParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(calcExprParser.COMMA, i);
		}
		public MultiExprContext(ParamsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterMultiExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitMultiExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamsContext @params() {
		ParamsContext _localctx = new ParamsContext(Context, State);
		EnterRule(_localctx, 30, RULE_params);
		int _la;
		try {
			_localctx = new MultiExprContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 116; ((MultiExprContext)_localctx).left = unaryparam();
			State = 121;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 117; Match(COMMA);
				State = 118; unaryparam();
				}
				}
				State = 123;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryparamContext : ParserRuleContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public BriefparamContext briefparam() {
			return GetRuleContext<BriefparamContext>(0);
		}
		public UnaryparamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryparam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterUnaryparam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitUnaryparam(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryparam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryparamContext unaryparam() {
		UnaryparamContext _localctx = new UnaryparamContext(Context, State);
		EnterRule(_localctx, 32, RULE_unaryparam);
		try {
			State = 126;
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 124; expr();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 125; briefparam();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BriefparamContext : ParserRuleContext {
		public BriefparamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_briefparam; } }
	 
		public BriefparamContext() { }
		public virtual void CopyFrom(BriefparamContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ContinueParamContext : BriefparamContext {
		public IToken sInx;
		public IToken eInx;
		public VarContext var() {
			return GetRuleContext<VarContext>(0);
		}
		public ITerminalNode[] COLON() { return GetTokens(calcExprParser.COLON); }
		public ITerminalNode COLON(int i) {
			return GetToken(calcExprParser.COLON, i);
		}
		public ITerminalNode[] NUMBER() { return GetTokens(calcExprParser.NUMBER); }
		public ITerminalNode NUMBER(int i) {
			return GetToken(calcExprParser.NUMBER, i);
		}
		public ContinueParamContext(BriefparamContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.EnterContinueParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalcExprListener typedListener = listener as IcalcExprListener;
			if (typedListener != null) typedListener.ExitContinueParam(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalcExprVisitor<TResult> typedVisitor = visitor as IcalcExprVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinueParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BriefparamContext briefparam() {
		BriefparamContext _localctx = new BriefparamContext(Context, State);
		EnterRule(_localctx, 34, RULE_briefparam);
		try {
			_localctx = new ContinueParamContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 128; var();
			State = 129; Match(COLON);
			State = 130; ((ContinueParamContext)_localctx).sInx = Match(NUMBER);
			State = 131; Match(COLON);
			State = 132; ((ContinueParamContext)_localctx).eInx = Match(NUMBER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x1F\x89\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x3\x2\x3\x2\x3\x2\x3\x3"+
		"\x3\x3\x3\x4\x3\x4\a\x4.\n\x4\f\x4\xE\x4\x31\v\x4\x3\x5\x3\x5\x3\x5\x3"+
		"\x6\x3\x6\a\x6\x38\n\x6\f\x6\xE\x6;\v\x6\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b"+
		"\x5\b\x43\n\b\x3\t\x3\t\x3\t\x5\tH\n\t\x3\n\x3\n\a\nL\n\n\f\n\xE\nO\v"+
		"\n\x3\v\x3\v\x3\v\x3\f\x3\f\a\fV\n\f\f\f\xE\fY\v\f\x3\r\x3\r\x3\r\x3\xE"+
		"\x5\xE_\n\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x5\xF\x66\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xFs\n\xF\x3"+
		"\x10\x3\x10\x3\x11\x3\x11\x3\x11\a\x11z\n\x11\f\x11\xE\x11}\v\x11\x3\x12"+
		"\x3\x12\x5\x12\x81\n\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3"+
		"\x13\x2\x2\x14\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \"$\x2"+
		"\x6\x3\x2\x5\b\x3\x2\t\n\x3\x2\v\f\x3\x2\r\xE\x87\x2&\x3\x2\x2\x2\x4)"+
		"\x3\x2\x2\x2\x6+\x3\x2\x2\x2\b\x32\x3\x2\x2\x2\n\x35\x3\x2\x2\x2\f<\x3"+
		"\x2\x2\x2\xE?\x3\x2\x2\x2\x10\x44\x3\x2\x2\x2\x12I\x3\x2\x2\x2\x14P\x3"+
		"\x2\x2\x2\x16S\x3\x2\x2\x2\x18Z\x3\x2\x2\x2\x1A^\x3\x2\x2\x2\x1Cr\x3\x2"+
		"\x2\x2\x1Et\x3\x2\x2\x2 v\x3\x2\x2\x2\"\x80\x3\x2\x2\x2$\x82\x3\x2\x2"+
		"\x2&\'\a\x13\x2\x2\'(\x5\x4\x3\x2(\x3\x3\x2\x2\x2)*\x5\x6\x4\x2*\x5\x3"+
		"\x2\x2\x2+/\x5\n\x6\x2,.\x5\b\x5\x2-,\x3\x2\x2\x2.\x31\x3\x2\x2\x2/-\x3"+
		"\x2\x2\x2/\x30\x3\x2\x2\x2\x30\a\x3\x2\x2\x2\x31/\x3\x2\x2\x2\x32\x33"+
		"\a\x3\x2\x2\x33\x34\x5\n\x6\x2\x34\t\x3\x2\x2\x2\x35\x39\x5\xE\b\x2\x36"+
		"\x38\x5\f\a\x2\x37\x36\x3\x2\x2\x2\x38;\x3\x2\x2\x2\x39\x37\x3\x2\x2\x2"+
		"\x39:\x3\x2\x2\x2:\v\x3\x2\x2\x2;\x39\x3\x2\x2\x2<=\a\x4\x2\x2=>\x5\xE"+
		"\b\x2>\r\x3\x2\x2\x2?\x42\x5\x10\t\x2@\x41\t\x2\x2\x2\x41\x43\x5\x10\t"+
		"\x2\x42@\x3\x2\x2\x2\x42\x43\x3\x2\x2\x2\x43\xF\x3\x2\x2\x2\x44G\x5\x12"+
		"\n\x2\x45\x46\t\x3\x2\x2\x46H\x5\x12\n\x2G\x45\x3\x2\x2\x2GH\x3\x2\x2"+
		"\x2H\x11\x3\x2\x2\x2IM\x5\x16\f\x2JL\x5\x14\v\x2KJ\x3\x2\x2\x2LO\x3\x2"+
		"\x2\x2MK\x3\x2\x2\x2MN\x3\x2\x2\x2N\x13\x3\x2\x2\x2OM\x3\x2\x2\x2PQ\t"+
		"\x4\x2\x2QR\x5\x16\f\x2R\x15\x3\x2\x2\x2SW\x5\x1A\xE\x2TV\x5\x18\r\x2"+
		"UT\x3\x2\x2\x2VY\x3\x2\x2\x2WU\x3\x2\x2\x2WX\x3\x2\x2\x2X\x17\x3\x2\x2"+
		"\x2YW\x3\x2\x2\x2Z[\t\x5\x2\x2[\\\x5\x1A\xE\x2\\\x19\x3\x2\x2\x2]_\t\x4"+
		"\x2\x2^]\x3\x2\x2\x2^_\x3\x2\x2\x2_`\x3\x2\x2\x2`\x61\x5\x1C\xF\x2\x61"+
		"\x1B\x3\x2\x2\x2\x62\x63\a\x1A\x2\x2\x63\x65\a\x15\x2\x2\x64\x66\x5 \x11"+
		"\x2\x65\x64\x3\x2\x2\x2\x65\x66\x3\x2\x2\x2\x66g\x3\x2\x2\x2gs\a\x16\x2"+
		"\x2hs\a\x1D\x2\x2is\a\x1B\x2\x2js\x5\x1E\x10\x2ks\a\x17\x2\x2ls\a\x18"+
		"\x2\x2ms\a\x19\x2\x2no\a\x15\x2\x2op\x5\x4\x3\x2pq\a\x16\x2\x2qs\x3\x2"+
		"\x2\x2r\x62\x3\x2\x2\x2rh\x3\x2\x2\x2ri\x3\x2\x2\x2rj\x3\x2\x2\x2rk\x3"+
		"\x2\x2\x2rl\x3\x2\x2\x2rm\x3\x2\x2\x2rn\x3\x2\x2\x2s\x1D\x3\x2\x2\x2t"+
		"u\a\x1A\x2\x2u\x1F\x3\x2\x2\x2v{\x5\"\x12\x2wx\a\x11\x2\x2xz\x5\"\x12"+
		"\x2yw\x3\x2\x2\x2z}\x3\x2\x2\x2{y\x3\x2\x2\x2{|\x3\x2\x2\x2|!\x3\x2\x2"+
		"\x2}{\x3\x2\x2\x2~\x81\x5\x4\x3\x2\x7F\x81\x5$\x13\x2\x80~\x3\x2\x2\x2"+
		"\x80\x7F\x3\x2\x2\x2\x81#\x3\x2\x2\x2\x82\x83\x5\x1E\x10\x2\x83\x84\a"+
		"\x14\x2\x2\x84\x85\a\x1D\x2\x2\x85\x86\a\x14\x2\x2\x86\x87\a\x1D\x2\x2"+
		"\x87%\x3\x2\x2\x2\r/\x39\x42GMW^\x65r{\x80";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
